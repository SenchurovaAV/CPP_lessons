0.
Сигнатура функции — это список ее аргументов. 

Пример одинаковых сигнатур:

float Sum (float a, float b) 
{
	return a + b;
}
float Comp (float a, float b) 
{
	return a * b;
}

Пример разных сигнатур:

float Sum (float a, float b) 
{
	return a + b;
}
float Sum (float a, float b, float c, int d) 
{
	return a + b + c + d;
}

1.
Полиморфизм — это возможность иметь несколько форм.

2.
Перегрузка функций в С++ - способ задать несколько различных функций с одинаковыми именами (но различными сигнатурами)
float Sum (float a, float b) 
{
	return a + b;
};

float Sum (float a, float b, int c) 
{
	return a + b + c;
};

3.
Аргументы по умолчанию — некоторые значения аргументов функции, которые принимаются, если при вызове функции не объявляется другое значение. Например, есть функция func с прототипом double func (double a = 0,  double b = 1, double c = -1). Тогда при ее вызове 
func (x, y) = func (x, y, -1);
func () = func (0, 1, -1);
func (x, y, z) -  аргументы по умолчанию не используются

4.
Шаблон функции — обобщенное описание функции, в котором не заданы типы переменных, и вместо обобщенного типа в шаблоне может быть подставлен любой тип, который передается в качестве параметра.
Шаблон нужен, чтобы использовать одинаковые алгоритмы для нескольких различных типов данных.
Например, имеем прототип шаблона 
template <typename Type> 
void Swap (T &a, T&b);
Тогда при первом определении типа Type (например, int) при вызове функции Swap генерируется функция Swap (int &a, int &b).
Ограничения шаблонов. При задании шаблона можно столкнуться с тем, что сгенерированная для данного типа функция не сможет корректно обработать данные типы. Например, если будет задана функция, прямо сравнивающая две переменные, она не сможет корректно обработать класс комплексных чисел таким же образом, как и две переменные типа int. Для этого можно использовать явную специализацию шаблонов.

5.
Явная специализация нужна, если существует некоторый шаблон, но для определенного типа данных нужно перегрузить шаблонную функцию, чтобы она иначе обрабатывала данные. Например:
template <typename T> // C++11
void composition(T a, T b)
{
    T t = a*b
}

struct complex {
    double Re;
    double Im;
};

// explicitly specialization
template <> void comp<complex>(complex a, complex b)
{
    
    complex t = {};
    t.Re = (a->Re)*(b->Re) - (a->Im)*(b->Im);
    t.Im = (a->Re)*(b->Im) + (a->Im)*(b->Re);
    
}

6.
Ссылочная переменная в С++ - новый тип данных, представляющая собой псевдоним ранее определенной переменной. Например:
Book_1 = & Crime_and_Punishment
 Тогда при использовании и изменении ссылки на переменную изменится также и сама переменная.

7.
При определении функции после ключевого слова inline каждый вызов функции будет заменяться на ее код. Ключевое слово может использоваться, например, при замене небольшого числа вызовов функции на тело функции. Тогда не придется обращаться к инструкциям по вызову функции. При большом числе вызовов (те замен на тело) увеличивается длина кода. 

8.
Ключевое слово auto позволяет не определять явно тип переменной, а позволяет компилятору самостоятельно определить тип переменной. Это может использоваться при определении переменной в разных областях видимости, например. 
Auto используется при определении типа полученной (определяемой) переменной, но не возвращаемой. Для определения типа возвращаемой переменной на основе входных данных используется decltype.
Template <typename T0, typename T1> auto Sum(T0 a, T1 b) →decltype (a+b) 
{
	return (a+b)
}
auto c = Sum(4, 4.68) 

