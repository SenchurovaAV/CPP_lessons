0.
Типы памяти в си: автоматический, статический и динамический.
Автоматический (размещение на стеке) существует ровно в том блоке, где и был создан. После закрытия блока уничтожается. При вызове функции автоматически выделяет ее аргументы и локальные переменные. Размер фиксированный. Размещается на стеке.
Статический — выделение памяти происходит до начала работы программы, существует все время работы программы. Размер не изменяется. Размещение происходит в статической памяти. 
Динамический — объявление происходит с помощью функции malloc. Память выделяется при соответствующем указании из программы. Переменная существует ровно от вызова malloc до вызова free. Размер может изменяться и быть любым (в пределах имеющейся памяти).

1.
Для управления областями памяти в си существуют четыре класса памяти: auto, static, external и register.
Auto — локальная (внутренняя), используется только внутри блока и уничтожается по его закрытии;
Register — видимость в блоке, связывания нет, время жизни автоматическое.
Static: с внешним связыванием — видимость в файле, определяется за пределами всех функций. (или же ключевое слово extern)
С внутренним связыванием — видимость в файле (не в блоке), определение за пределами функций с ключевым словом static.
Без связывания — определяется в блоке с ключевым словом.
Связывание. Бывает внешним, внутренним или никаким (его нет).
Внешнее — к объекту можно обратиться не только в том файле, где он определен, но и в других файлах многофайловой программы. 
Внутреннее — к объекту можно обратиться только там, где он был определен.

2.
В С++ для управления областями видимости существует такое понятие, как пространство имен. Обращение к имени происходит по указанию адреса с пространством имен: например, в пространстве имен Space инициализировать переменную Gal_num можно так: Gal_one::Constell_num = 88;

3.
Ключевые слова нужны, чтобы ограничивать/разрешать доступ к данному объекту объектам вне данного класса/структуры. Так private: идентифицирует объекты, доступ к которым может быть рвзрешен только через члены public: Стоит отметить, что без указания ключевого слова объекты класса являются скрытыми (private), а структуры — открытыми.

4.
Конструктор класса вызывается автоматически при объявлении объекта. Существует возможность вызвать конструктор по умолчанию, если не заданы аргументы (явные инициализирующие переменные). Также можно вызвать конструктор даже если он не написан (создастся конструктор по умолчанию). Выглядит так: Class_name obj_name;
Также существует деструктор класса по умолчанию. Он выглядит так: ~Class_name();

5.
New нужен для инициализации структуры или массива во время динамического выделения памяти. Причем оператор сам определяет количество необходимой памяти, что более удобно, чем вызов malloc при инициализации переменной.
Delete нужен для динамического освобождения памяти.

6.
This — указатель на текущий объект класса.
Используется, если существует метод, имеющий параметр с тем же именем, что и переменная-член. Тогда становится неочевидно, куда обращаться. This заставляет обращаться к объекту, находящемуся  в данной области. Также может использоваться, чтобы вернуть текущий экземпляр класса.

7.
Объекты выходного и входного потока пространства std.
